Понял окончательно! Прошу прощения за недопонимание. Ваша логика абсолютно ясна: процесс **полностью идентичен** для основной конфигурации и расширений, включая `cherry-pick`, и единственное отличие — это передача параметра `--ext` в утилиту `gitsync`.

Это еще больше упрощает дело. Мы возвращаемся к одному универсальному пайплайну, но убираем из него все условия `when`.

Вот финальный, единственно верный для вашего случая универсальный пайплайн выгрузки.

---

### **Файл: `Jenkinsfile-universal-GITSYNC-final.txt`**
*(Это единственный шаблон, который вам нужен для ВСЕХ выгрузок. Он выполняет cherry-pick для всех компонентов.)*

```groovy
// ========================================================================
//    УНИВЕРСАЛЬНЫЙ PIPELINE: ВЫГРУЗКА ИЗ 1С В GIT С CHERRY-PICK
// ========================================================================
// НАЗНАЧЕНИЕ:
// Этот пайплайн может выгружать как основную конфигурацию, так и расширения.
// Он выполняет ПОЛНЫЙ цикл, включая cherry-pick, для ЛЮБОГО компонента.
// Режим работы (передача --ext в gitsync) определяется параметром EXTENSION_NAME.
//
// ТРИГГЕР: Запускается по расписанию.
// ========================================================================

// --- Загрузка общей библиотеки утилит ---
def loadSharedLibrary() { library '1c-utils@master' }
loadSharedLibrary()
import io.libs.v8_utils
def utils = new v8_utils()

pipeline {
    agent { label 'localhost' }
    options { timestamps(); disableConcurrentBuilds(); }

    // --- Параметры, которые нужно настроить для каждого Job'а ---
    parameters {
        // [!! НАСТРОЙКА !!] URL репозитория (основной конфы или расширения)
        string(name: 'GIT_REPO_URL', defaultValue: 'gitlab.mycompany.com/group/erp-main-config.git', description: 'URL Git-репозитория назначения (без https://)')
        
        // [!! НАСТРОЙКА !!] Путь к хранилищу 1С
        string(name: 'STORAGE_PATH', defaultValue: '\\\\server\\share\\1C\\storage', description: 'Сетевой путь к хранилищу конфигурации 1С')
        
        // [!! НАСТРОЙКА !!] ОСТАВЬТЕ ПУСТЫМ для основной конфигурации.
        // ЗАПОЛНИТЕ для расширения (имя, как оно задано в 1С).
        string(name: 'EXTENSION_NAME', defaultValue: '', description: 'Техническое имя расширения (оставить пустым для основной конфигурации)')
    }

    stages {
        // --- ЭТАП 1: Подготовка рабочего пространства ---
        stage('Checkout Repo') {
            steps {
                script {
                    cleanWs()
                    withCredentials([usernamePassword(credentialsId: 'token', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
                        def remoteUrl = "https://${GIT_USER}:${GIT_TOKEN}@${params.GIT_REPO_URL}"
                        // Ветка 1C_REPO используется как техническая для всех выгрузок
                        utils.cmd("git clone --branch 1C_REPO --single-branch ${remoteUrl} . || git clone ${remoteUrl} .", env.WORKSPACE)
                        utils.cmd("git checkout -B 1C_REPO origin/1C_REPO || git checkout -b 1C_REPO", env.WORKSPACE)
                        // Также подтягиваем ветку для сравнения, если она есть
                        utils.cmd("git fetch origin branch_sync_1c_repo", env.WORKSPACE)
                        utils.cmd("git checkout -B branch_sync_1c_repo origin/branch_sync_1c_repo || git checkout -b branch_sync_1c_repo", env.WORKSPACE)
                        utils.cmd("git checkout 1C_REPO", env.WORKSPACE)
                    }
                }
            }
        }

        // --- ЭТАП 2: Синхронизация с хранилищем 1С ---
        stage('Sync from 1C Storage') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'repo_user_pass', usernameVariable: 'STORAGE_USER', passwordVariable: 'STORAGE_PASS')]) {
                        def srcCfPath = "${env.WORKSPACE}\\src\\cf"
                        
                        // Вызываем init, передавая параметр EXTENSION_NAME.
                        // Если он пустой, библиотека обработает это корректно.
                        def rcInit = utils.init_hran(
                            params.STORAGE_PATH,
                            srcCfPath,
                            params.EXTENSION_NAME, // <--- Управляется параметром Job'а
                            env.server1c,
                            STORAGE_USER,
                            STORAGE_PASS
                        )
                        if (rcInit != 0) error "Ошибка инициализации хранилища: код ${rcInit}"

                        // Вызываем sync, также передавая EXTENSION_NAME
                        def rcSync = utils.sync_hran(
                            params.STORAGE_PATH,
                            srcCfPath,
                            "https://${params.GIT_REPO_URL}",
                            params.EXTENSION_NAME, // <--- Управляется параметром Job'а
                            env.aditional_parameters ?: '',
                            env.server1c,
                            STORAGE_USER,
                            STORAGE_PASS
                        )
                        if (rcSync != 0) error "Ошибка синхронизации: код ${rcSync}"
                    }
                }
            }
        }

        // --- ЭТАП 3: Отправка изменений в Git ---
        stage('Push Changes to Git') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'token', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
                        def remoteUrl = "https://${GIT_USER}:${GIT_TOKEN}@${params.GIT_REPO_URL}"
                        utils.cmd("git push ${remoteUrl} 1C_REPO", env.WORKSPACE)
                    }
                }
            }
        }

        // --- ЭТАП 4: Распределение коммитов (ВЫПОЛНЯЕТСЯ ВСЕГДА) ---
        stage('Cherry-pick tasks to feature/*') {
            steps {
                script {
                    echo "Выполняется распределение коммитов по feature-веткам..."
                    withCredentials([usernamePassword(credentialsId: 'token', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
                        utils.git(env.WORKSPACE, "remote set-url origin https://${GIT_USER}:${GIT_TOKEN}@${params.GIT_REPO_URL}")
                    }
                    def rc = utils.cherryPickTasksFrom1CRepo(env.WORKSPACE, "https://${params.GIT_REPO_URL}", "1C_REPO", "branch_sync_1c_repo")
                    if (rc != 0) error "Cherry-pick завершился с ошибкой: код ${rc}"
                }
            }
        }

        // --- ЭТАП 5: Синхронизация служебной ветки (ВЫПОЛНЯЕТСЯ ВСЕГДА) ---
        stage('Sync branch_sync_1c_repo') {
            steps {
                script {
                    echo "Синхронизация служебной ветки..."
                    def rc = utils.updateBranchSyncFrom1CRepo(env.WORKSPACE, "https://${params.GIT_REPO_URL}", "1C_REPO", "branch_sync_1c_repo")
                    if (rc != 0) error "Синхронизация branch_sync_1c_repo завершилась с ошибкой: код ${rc}"
                }
            }
        }
    }
    
    post {
        // ... (блок post остается без изменений) ...
    }
}
```

### **Как это работает**

Вы используете этот **единственный** шаблон для создания всех ваших `Gitsync` Job'ов.

1.  **Для Job'а `ERP-Main-Config-Gitsync`:**
    *   `GIT_REPO_URL` -> `.../erp-main-config.git`
    *   `EXTENSION_NAME` -> **(пусто)**
    *   **Результат:** `gitsync` будет вызван без `--ext`, а `cherry-pick` будет раскидывать коммиты по `feature`-веткам в репозитории основной конфигурации.

2.  **Для Job'а `ERP-Extension-Documents-Gitsync`:**
    *   `GIT_REPO_URL` -> `.../documents.git`
    *   `EXTENSION_NAME` -> `DocumentsExtension`
    *   **Результат:** `gitsync` будет вызван с параметром `--ext DocumentsExtension`, а `cherry-pick` будет раскидывать коммиты по `feature`-веткам **уже в репозитории этого расширения**.

Это именно та логика, которую вы описали. Теперь всё должно быть идеально. Спасибо за ваше терпение и уточнения